/* automatically generated by rust-bindgen */

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type speed_t = ::std::os::raw::c_uint;
#[doc = "@struct coord_s"]
#[doc = "@brief Time solution required for timestamp to absolute time conversion"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tref {
    pub systime: time_t,
    #[doc = "> system time when solution was calculated"]
    pub count_us: u32,
    #[doc = "> reference concentrator internal timestamp"]
    pub utc: timespec,
    #[doc = "> reference UTC time (from GPS/NMEA)"]
    pub gps: timespec,
    #[doc = "> reference GPS time (since 01.Jan.1980)"]
    pub xtal_err: f64,
}
#[test]
fn bindgen_test_layout_tref() {
    assert_eq!(
        ::std::mem::size_of::<tref>(),
        56usize,
        concat!("Size of: ", stringify!(tref))
    );
    assert_eq!(
        ::std::mem::align_of::<tref>(),
        8usize,
        concat!("Alignment of ", stringify!(tref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tref>())).systime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tref),
            "::",
            stringify!(systime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tref>())).count_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tref),
            "::",
            stringify!(count_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tref>())).utc as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(tref), "::", stringify!(utc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tref>())).gps as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(tref), "::", stringify!(gps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tref>())).xtal_err as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tref),
            "::",
            stringify!(xtal_err)
        )
    );
}
#[doc = "@struct coord_s"]
#[doc = "@brief Geodesic coordinates"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct coord_s {
    pub lat: f64,
    #[doc = "> latitude [-90,90] (North +, South -)"]
    pub lon: f64,
    #[doc = "> longitude [-180,180] (East +, West -)"]
    pub alt: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_coord_s() {
    assert_eq!(
        ::std::mem::size_of::<coord_s>(),
        24usize,
        concat!("Size of: ", stringify!(coord_s))
    );
    assert_eq!(
        ::std::mem::align_of::<coord_s>(),
        8usize,
        concat!("Alignment of ", stringify!(coord_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coord_s>())).lat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coord_s),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coord_s>())).lon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(coord_s),
            "::",
            stringify!(lon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coord_s>())).alt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(coord_s),
            "::",
            stringify!(alt)
        )
    );
}
pub const gps_msg_UNKNOWN: gps_msg = 0;
#[doc = "> neutral value"]
pub const gps_msg_IGNORED: gps_msg = 1;
#[doc = "> frame was not parsed by the system"]
pub const gps_msg_INVALID: gps_msg = 2;
#[doc = "> system try to parse frame but failed"]
pub const gps_msg_INCOMPLETE: gps_msg = 3;
#[doc = "> frame parsed was missing bytes"]
pub const gps_msg_NMEA_RMC: gps_msg = 4;
#[doc = "> Recommended Minimum data (time + date)"]
pub const gps_msg_NMEA_GGA: gps_msg = 5;
#[doc = "> Global positioning system fix data (pos + alt)"]
pub const gps_msg_NMEA_GNS: gps_msg = 6;
#[doc = "> GNSS fix data (pos + alt, sat number)"]
pub const gps_msg_NMEA_ZDA: gps_msg = 7;
#[doc = "> Time and Date"]
pub const gps_msg_NMEA_GBS: gps_msg = 8;
#[doc = "> GNSS Satellite Fault Detection"]
pub const gps_msg_NMEA_GST: gps_msg = 9;
#[doc = "> GNSS Pseudo Range Error Statistics"]
pub const gps_msg_NMEA_GSA: gps_msg = 10;
#[doc = "> GNSS DOP and Active Satellites (sat number)"]
pub const gps_msg_NMEA_GSV: gps_msg = 11;
#[doc = "> GNSS Satellites in View (sat SNR)"]
pub const gps_msg_NMEA_GLL: gps_msg = 12;
#[doc = "> Latitude and longitude, with time fix and status"]
pub const gps_msg_NMEA_TXT: gps_msg = 13;
#[doc = "> Text Transmission"]
pub const gps_msg_NMEA_VTG: gps_msg = 14;
#[doc = "> Course over ground and Ground speed"]
pub const gps_msg_UBX_NAV_TIMEGPS: gps_msg = 15;
#[doc = "> GPS Time Solution"]
pub const gps_msg_UBX_NAV_TIMEUTC: gps_msg = 16;
#[doc = "@enum gps_msg"]
#[doc = "@brief Type of GPS (and other GNSS) sentences"]
pub type gps_msg = u32;
extern "C" {
    #[doc = "@brief Configure a GPS module"]
    #[doc = ""]
    #[doc = "@param tty_path path to the TTY connected to the GPS"]
    #[doc = "@param gps_familly parameter (eg. ubx6 for uBlox gen.6)"]
    #[doc = "@param target_brate target baudrate for communication (0 keeps default target baudrate)"]
    #[doc = "@param fd_ptr pointer to a variable to receive file descriptor on GPS tty"]
    #[doc = "@return success if the function was able to connect and configure a GPS module"]
    pub fn lgw_gps_enable(
        tty_path: *mut ::std::os::raw::c_char,
        gps_familly: *mut ::std::os::raw::c_char,
        target_brate: speed_t,
        fd_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Restore GPS serial configuration and close serial device"]
    #[doc = ""]
    #[doc = "@param fd file descriptor on GPS tty"]
    #[doc = "@return success if the function was able to complete"]
    pub fn lgw_gps_disable(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Parse messages coming from the GPS system (or other GNSS)"]
    #[doc = ""]
    #[doc = "@param serial_buff pointer to the string to be parsed"]
    #[doc = "@param buff_size maximum string lengths for NMEA parsing (incl. null char)"]
    #[doc = "@return type of frame parsed"]
    #[doc = ""]
    #[doc = "The RAW NMEA sentences are parsed to a global set of variables shared with the"]
    #[doc = "lgw_gps_get function."]
    #[doc = "If the lgw_parse_nmea and lgw_gps_get are used in different threads, a mutex"]
    #[doc = "lock must be acquired before calling either function."]
    pub fn lgw_parse_nmea(
        serial_buff: *const ::std::os::raw::c_char,
        buff_size: ::std::os::raw::c_int,
    ) -> gps_msg;
}
extern "C" {
    #[doc = "@brief Parse Ublox proprietary messages coming from the GPS system"]
    #[doc = ""]
    #[doc = "@param serial_buff pointer to the string to be parsed"]
    #[doc = "@param buff_size maximum string lengths for UBX parsing (incl. null char)"]
    #[doc = "@param msg_size number of bytes parsed as UBX message if found"]
    #[doc = "@return type of frame parsed"]
    #[doc = ""]
    #[doc = "The RAW UBX sentences are parsed to a global set of variables shared with the"]
    #[doc = "lgw_gps_get function."]
    #[doc = "If the lgw_parse_ubx and lgw_gps_get are used in different threads, a mutex"]
    #[doc = "lock must be acquired before calling either function."]
    pub fn lgw_parse_ubx(
        serial_buff: *const ::std::os::raw::c_char,
        buff_size: usize,
        msg_size: *mut usize,
    ) -> gps_msg;
}
extern "C" {
    #[doc = "@brief Get the GPS solution (space & time) for the concentrator"]
    #[doc = ""]
    #[doc = "@param utc pointer to store UTC time, with ns precision (NULL to ignore)"]
    #[doc = "@param gps_time pointer to store GPS time, with ns precision (NULL to ignore)"]
    #[doc = "@param loc pointer to store coordinates (NULL to ignore)"]
    #[doc = "@param err pointer to store coordinates standard deviation (NULL to ignore)"]
    #[doc = "@return success if the chosen elements could be returned"]
    #[doc = ""]
    #[doc = "This function read the global variables generated by the NMEA/UBX parsing"]
    #[doc = "functions lgw_parse_nmea/lgw_parse_ubx. It returns time and location data in a"]
    #[doc = "format that is exploitable by other functions in that library sub-module."]
    #[doc = "If the lgw_parse_nmea/lgw_parse_ubx and lgw_gps_get are used in different"]
    #[doc = "threads, a mutex lock must be acquired before calling either function."]
    pub fn lgw_gps_get(
        utc: *mut timespec,
        gps_time: *mut timespec,
        loc: *mut coord_s,
        err: *mut coord_s,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Get time and position information from the serial GPS last message received"]
    #[doc = "@param utc UTC time, with ns precision (leap seconds are ignored)"]
    #[doc = "@param gps_time timestamp of last time pulse from the GPS module converted to the UNIX epoch"]
    #[doc = "(leap seconds are ignored)"]
    #[doc = "@param loc location information"]
    #[doc = "@param err location error estimate if supported"]
    #[doc = "@return success if timestamp was read and time reference could be refreshed"]
    #[doc = ""]
    #[doc = "Set systime to 0 in ref to trigger initial synchronization."]
    pub fn lgw_gps_sync(
        ref_: *mut tref,
        count_us: u32,
        utc: timespec,
        gps_time: timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Convert concentrator timestamp counter value to UTC time"]
    #[doc = ""]
    #[doc = "@param ref time reference structure required for time conversion"]
    #[doc = "@param count_us internal timestamp counter of the LoRa concentrator"]
    #[doc = "@param utc pointer to store UTC time, with ns precision (leap seconds ignored)"]
    #[doc = "@return success if the function was able to convert timestamp to UTC"]
    #[doc = ""]
    #[doc = "This function is typically used when a packet is received to transform the"]
    #[doc = "internal counter-based timestamp in an absolute timestamp with an accuracy in"]
    #[doc = "the order of a couple microseconds (ns resolution)."]
    pub fn lgw_cnt2utc(ref_: tref, count_us: u32, utc: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Convert UTC time to concentrator timestamp counter value"]
    #[doc = ""]
    #[doc = "@param ref time reference structure required for time conversion"]
    #[doc = "@param utc UTC time, with ns precision (leap seconds are ignored)"]
    #[doc = "@param count_us pointer to store internal timestamp counter of LoRa concentrator"]
    #[doc = "@return success if the function was able to convert UTC to timestamp"]
    #[doc = ""]
    #[doc = "This function is typically used when a packet must be sent at an accurate time"]
    #[doc = "(eg. to send a piggy-back response after receiving a packet from a node) to"]
    #[doc = "transform an absolute UTC time into a matching internal concentrator timestamp."]
    pub fn lgw_utc2cnt(ref_: tref, utc: timespec, count_us: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Convert concentrator timestamp counter value to GPS time"]
    #[doc = ""]
    #[doc = "@param ref time reference structure required for time conversion"]
    #[doc = "@param count_us internal timestamp counter of the LoRa concentrator"]
    #[doc = "@param gps_time pointer to store GPS time, with ns precision (leap seconds ignored)"]
    #[doc = "@return success if the function was able to convert timestamp to GPS time"]
    #[doc = ""]
    #[doc = "This function is typically used when a packet is received to transform the"]
    #[doc = "internal counter-based timestamp in an absolute timestamp with an accuracy in"]
    #[doc = "the order of a millisecond."]
    pub fn lgw_cnt2gps(ref_: tref, count_us: u32, gps_time: *mut timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Convert GPS time to concentrator timestamp counter value"]
    #[doc = ""]
    #[doc = "@param ref time reference structure required for time conversion"]
    #[doc = "@param gps_time GPS time, with ns precision (leap seconds are ignored)"]
    #[doc = "@param count_us pointer to store internal timestamp counter of LoRa concentrator"]
    #[doc = "@return success if the function was able to convert GPS time to timestamp"]
    #[doc = ""]
    #[doc = "This function is typically used when a packet must be sent at an accurate time"]
    #[doc = "(eg. to send a piggy-back response after receiving a packet from a node) to"]
    #[doc = "transform an absolute GPS time into a matching internal concentrator timestamp."]
    pub fn lgw_gps2cnt(ref_: tref, gps_time: timespec, count_us: *mut u32)
        -> ::std::os::raw::c_int;
}
pub const lgw_radio_type_e_LGW_RADIO_TYPE_NONE: lgw_radio_type_e = 0;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1255: lgw_radio_type_e = 1;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1257: lgw_radio_type_e = 2;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1272: lgw_radio_type_e = 3;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1276: lgw_radio_type_e = 4;
#[doc = "@enum lgw_radio_type_e"]
#[doc = "@brief Radio types that can be found on the LoRa Gateway"]
pub type lgw_radio_type_e = u32;
#[doc = "@struct lgw_conf_board_s"]
#[doc = "@brief Configuration structure for board specificities"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_board_s {
    pub lorawan_public: bool,
    #[doc = "> Enable ONLY for *public* networks using the LoRa MAC protocol"]
    pub clksrc: u8,
}
#[test]
fn bindgen_test_layout_lgw_conf_board_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_board_s>(),
        2usize,
        concat!("Size of: ", stringify!(lgw_conf_board_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_board_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_conf_board_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_board_s>())).lorawan_public as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_board_s),
            "::",
            stringify!(lorawan_public)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_board_s>())).clksrc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_board_s),
            "::",
            stringify!(clksrc)
        )
    );
}
#[doc = "@struct lgw_conf_lbt_chan_s"]
#[doc = "@brief Configuration structure for LBT channels"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_lbt_chan_s {
    pub freq_hz: u32,
    pub scan_time_us: u16,
}
#[test]
fn bindgen_test_layout_lgw_conf_lbt_chan_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_lbt_chan_s>(),
        8usize,
        concat!("Size of: ", stringify!(lgw_conf_lbt_chan_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_lbt_chan_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_lbt_chan_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_chan_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_chan_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lgw_conf_lbt_chan_s>())).scan_time_us as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_chan_s),
            "::",
            stringify!(scan_time_us)
        )
    );
}
#[doc = "@struct lgw_conf_lbt_s"]
#[doc = "@brief Configuration structure for LBT specificities"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_lbt_s {
    pub enable: bool,
    #[doc = "> enable or disable LBT"]
    pub rssi_target: i8,
    #[doc = "> RSSI threshold to detect if channel is busy or not (dBm)"]
    pub nb_channel: u8,
    #[doc = "> number of LBT channels"]
    pub channels: [lgw_conf_lbt_chan_s; 8usize],
    pub rssi_offset: i8,
}
#[test]
fn bindgen_test_layout_lgw_conf_lbt_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_lbt_s>(),
        72usize,
        concat!("Size of: ", stringify!(lgw_conf_lbt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_lbt_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_lbt_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).rssi_target as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(rssi_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).nb_channel as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(nb_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).channels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).rssi_offset as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(rssi_offset)
        )
    );
}
#[doc = "@struct lgw_conf_rxrf_s"]
#[doc = "@brief Configuration structure for a RF chain"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lgw_conf_rxrf_s {
    pub enable: bool,
    #[doc = "> enable or disable that RF chain"]
    pub freq_hz: u32,
    #[doc = "> center frequency of the radio in Hz"]
    pub rssi_offset: f32,
    #[doc = "> Board-specific RSSI correction factor"]
    pub type_: lgw_radio_type_e,
    #[doc = "> Radio type for that RF chain (SX1255, SX1257....)"]
    pub tx_enable: bool,
    #[doc = "> enable or disable TX on that RF chain"]
    pub tx_notch_freq: u32,
}
#[test]
fn bindgen_test_layout_lgw_conf_rxrf_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_rxrf_s>(),
        24usize,
        concat!("Size of: ", stringify!(lgw_conf_rxrf_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_rxrf_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_rxrf_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).freq_hz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).rssi_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(rssi_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).tx_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(tx_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).tx_notch_freq as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(tx_notch_freq)
        )
    );
}
impl Default for lgw_conf_rxrf_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_conf_rxif_s"]
#[doc = "@brief Configuration structure for an IF chain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_rxif_s {
    pub enable: bool,
    #[doc = "> enable or disable that IF chain"]
    pub rf_chain: u8,
    #[doc = "> to which RF chain is that IF chain associated"]
    pub freq_hz: i32,
    #[doc = "> center frequ of the IF chain, relative to RF chain frequency"]
    pub bandwidth: u8,
    #[doc = "> RX bandwidth, 0 for default"]
    pub datarate: u32,
    #[doc = "> RX datarate, 0 for default"]
    pub sync_word_size: u8,
    #[doc = "> size of FSK sync word (number of bytes, 0 for default)"]
    pub sync_word: u64,
}
#[test]
fn bindgen_test_layout_lgw_conf_rxif_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_rxif_s>(),
        32usize,
        concat!("Size of: ", stringify!(lgw_conf_rxif_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_rxif_s>(),
        8usize,
        concat!("Alignment of ", stringify!(lgw_conf_rxif_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).rf_chain as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).freq_hz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).bandwidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).datarate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).sync_word_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(sync_word_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).sync_word as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(sync_word)
        )
    );
}
#[doc = "@struct lgw_pkt_rx_s"]
#[doc = "@brief Structure containing the metadata of a packet that was received and a pointer to the payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lgw_pkt_rx_s {
    pub freq_hz: u32,
    #[doc = "> central frequency of the IF chain"]
    pub if_chain: u8,
    #[doc = "> by which IF chain was packet received"]
    pub status: u8,
    #[doc = "> status of the received packet"]
    pub count_us: u32,
    #[doc = "> internal concentrator counter for timestamping, 1 microsecond resolution"]
    pub rf_chain: u8,
    #[doc = "> through which RF chain the packet was received"]
    pub modulation: u8,
    #[doc = "> modulation used by the packet"]
    pub bandwidth: u8,
    #[doc = "> modulation bandwidth (LoRa only)"]
    pub datarate: u32,
    #[doc = "> RX datarate of the packet (SF for LoRa)"]
    pub coderate: u8,
    #[doc = "> error-correcting code of the packet (LoRa only)"]
    pub rssi: f32,
    #[doc = "> average packet RSSI in dB"]
    pub snr: f32,
    #[doc = "> average packet SNR, in dB (LoRa only)"]
    pub snr_min: f32,
    #[doc = "> minimum packet SNR, in dB (LoRa only)"]
    pub snr_max: f32,
    #[doc = "> maximum packet SNR, in dB (LoRa only)"]
    pub crc: u16,
    #[doc = "> CRC that was received in the payload"]
    pub size: u16,
    #[doc = "> payload size in bytes"]
    pub payload: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_lgw_pkt_rx_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_pkt_rx_s>(),
        300usize,
        concat!("Size of: ", stringify!(lgw_pkt_rx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_pkt_rx_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_pkt_rx_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).if_chain as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(if_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).status as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).count_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(count_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).rf_chain as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).modulation as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).bandwidth as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).datarate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).coderate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(coderate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).rssi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr_min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr_max as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).crc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).size as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).payload as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for lgw_pkt_rx_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_pkt_tx_s"]
#[doc = "@brief Structure containing the configuration of a packet to send and a pointer to the payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lgw_pkt_tx_s {
    pub freq_hz: u32,
    #[doc = "> center frequency of TX"]
    pub tx_mode: u8,
    #[doc = "> select on what event/time the TX is triggered"]
    pub count_us: u32,
    #[doc = "> timestamp or delay in microseconds for TX trigger"]
    pub rf_chain: u8,
    #[doc = "> through which RF chain will the packet be sent"]
    pub rf_power: i8,
    #[doc = "> TX power, in dBm"]
    pub modulation: u8,
    #[doc = "> modulation to use for the packet"]
    pub bandwidth: u8,
    #[doc = "> modulation bandwidth (LoRa only)"]
    pub datarate: u32,
    #[doc = "> TX datarate (baudrate for FSK, SF for LoRa)"]
    pub coderate: u8,
    #[doc = "> error-correcting code of the packet (LoRa only)"]
    pub invert_pol: bool,
    #[doc = "> invert signal polarity, for orthogonal downlinks (LoRa only)"]
    pub f_dev: u8,
    #[doc = "> frequency deviation, in kHz (FSK only)"]
    pub preamble: u16,
    #[doc = "> set the preamble length, 0 for default"]
    pub no_crc: bool,
    #[doc = "> if true, do not send a CRC in the packet"]
    pub no_header: bool,
    #[doc = "> if true, enable implicit header mode (LoRa), fixed length (FSK)"]
    pub size: u16,
    #[doc = "> payload size in bytes"]
    pub payload: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_lgw_pkt_tx_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_pkt_tx_s>(),
        288usize,
        concat!("Size of: ", stringify!(lgw_pkt_tx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_pkt_tx_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_pkt_tx_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).tx_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(tx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).count_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(count_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).rf_chain as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).rf_power as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(rf_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).modulation as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).bandwidth as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).datarate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).coderate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(coderate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).invert_pol as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(invert_pol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).f_dev as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(f_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).preamble as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(preamble)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).no_crc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(no_crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).no_header as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(no_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).payload as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for lgw_pkt_tx_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_tx_gain_s"]
#[doc = "@brief Structure containing all gains of Tx chain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_tx_gain_s {
    pub dig_gain: u8,
    #[doc = "> 2 bits, control of the digital gain of SX1301"]
    pub pa_gain: u8,
    #[doc = "> 2 bits, control of the external PA (SX1301 I/O)"]
    pub dac_gain: u8,
    #[doc = "> 2 bits, control of the radio DAC"]
    pub mix_gain: u8,
    #[doc = "> 4 bits, control of the radio mixer"]
    pub rf_power: i8,
}
#[test]
fn bindgen_test_layout_lgw_tx_gain_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_tx_gain_s>(),
        5usize,
        concat!("Size of: ", stringify!(lgw_tx_gain_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_tx_gain_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_tx_gain_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).dig_gain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(dig_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).pa_gain as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(pa_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).dac_gain as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(dac_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).mix_gain as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(mix_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).rf_power as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(rf_power)
        )
    );
}
#[doc = "@struct lgw_tx_gain_lut_s"]
#[doc = "@brief Structure defining the Tx gain LUT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_tx_gain_lut_s {
    pub lut: [lgw_tx_gain_s; 16usize],
    #[doc = "> Array of Tx gain struct"]
    pub size: u8,
}
#[test]
fn bindgen_test_layout_lgw_tx_gain_lut_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_tx_gain_lut_s>(),
        81usize,
        concat!("Size of: ", stringify!(lgw_tx_gain_lut_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_tx_gain_lut_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_tx_gain_lut_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_lut_s>())).lut as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_lut_s),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_lut_s>())).size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_lut_s),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = "@brief Configure the gateway board"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_board_setconf(conf: lgw_conf_board_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure the gateway lbt function"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_lbt_setconf(conf: lgw_conf_lbt_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure an RF chain (must configure before start)"]
    #[doc = "@param rf_chain number of the RF chain to configure [0, LGW_RF_CHAIN_NB - 1]"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_rxrf_setconf(rf_chain: u8, conf: lgw_conf_rxrf_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure an IF chain + modem (must configure before start)"]
    #[doc = "@param if_chain number of the IF chain + modem to configure [0, LGW_IF_CHAIN_NB - 1]"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_rxif_setconf(if_chain: u8, conf: lgw_conf_rxif_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure the Tx gain LUT"]
    #[doc = "@param pointer to structure defining the LUT"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_txgain_setconf(conf: *mut lgw_tx_gain_lut_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Connect to the LoRa concentrator, reset it and configure it according to previously set parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Stop the LoRa concentrator and disconnect it"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief A non-blocking function that will fetch up to 'max_pkt' packets from the LoRa concentrator FIFO and data buffer"]
    #[doc = "@param max_pkt maximum number of packet that must be retrieved (equal to the size of the array of struct)"]
    #[doc = "@param pkt_data pointer to an array of struct that will receive the packet metadata and payload pointers"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, else the number of packets retrieved"]
    pub fn lgw_receive(max_pkt: u8, pkt_data: *mut lgw_pkt_rx_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Schedule a packet to be send immediately or after a delay depending on tx_mode"]
    #[doc = "@param pkt_data structure containing the data and metadata for the packet to send"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    #[doc = ""]
    #[doc = "circuitry to start and be stable. This delay is adjusted by the HAL depending"]
    #[doc = "on the board version (lgw_i_tx_start_delay_us)."]
    #[doc = ""]
    #[doc = "In 'timestamp' mode, this is transparent: the modem is started"]
    #[doc = "lgw_i_tx_start_delay_us microseconds before the user-set timestamp value is"]
    #[doc = "reached, the preamble of the packet start right when the internal timestamp"]
    #[doc = "counter reach target value."]
    #[doc = ""]
    #[doc = "In 'immediate' mode, the packet is emitted as soon as possible: transferring the"]
    #[doc = "packet (and its parameters) from the host to the concentrator takes some time,"]
    #[doc = "then there is the lgw_i_tx_start_delay_us, then the packet is emitted."]
    #[doc = ""]
    #[doc = "In 'triggered' mode (aka PPS/GPS mode), the packet, typically a beacon, is"]
    #[doc = "emitted lgw_i_tx_start_delay_us microsenconds after a rising edge of the"]
    #[doc = "trigger signal. Because there is no way to anticipate the triggering event and"]
    #[doc = "start the analog circuitry beforehand, that delay must be taken into account in"]
    #[doc = "the protocol."]
    pub fn lgw_send(pkt_data: lgw_pkt_tx_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Give the the status of different part of the LoRa concentrator"]
    #[doc = "@param select is used to select what status we want to know"]
    #[doc = "@param code is used to return the status code"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_status(select: u8, code: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Abort a currently scheduled or ongoing TX"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_abort_tx() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Return value of internal counter when latest event (eg GPS pulse) was captured"]
    #[doc = "@param trig_cnt_us pointer to receive timestamp value"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_get_trigcnt(trig_cnt_us: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Allow user to check the version/options of the library once compiled"]
    #[doc = "@return pointer on a human-readable null terminated string"]
    pub fn lgw_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Return time on air of given packet, in milliseconds"]
    #[doc = "@param packet is a pointer to the packet structure"]
    #[doc = "@return the packet time on air in milliseconds"]
    pub fn lgw_time_on_air(packet: *mut lgw_pkt_tx_s) -> u32;
}
