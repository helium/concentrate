/* automatically generated by rust-bindgen */

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_NONE: lgw_radio_type_e = 0;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1255: lgw_radio_type_e = 1;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1257: lgw_radio_type_e = 2;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1272: lgw_radio_type_e = 3;
pub const lgw_radio_type_e_LGW_RADIO_TYPE_SX1276: lgw_radio_type_e = 4;
#[doc = "@enum lgw_radio_type_e"]
#[doc = "@brief Radio types that can be found on the LoRa Gateway"]
pub type lgw_radio_type_e = u32;
#[doc = "@struct lgw_conf_board_s"]
#[doc = "@brief Configuration structure for board specificities"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_board_s {
    pub lorawan_public: bool,
    #[doc = "> Enable ONLY for *public* networks using the LoRa MAC protocol"]
    pub clksrc: u8,
}
#[test]
fn bindgen_test_layout_lgw_conf_board_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_board_s>(),
        2usize,
        concat!("Size of: ", stringify!(lgw_conf_board_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_board_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_conf_board_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_board_s>())).lorawan_public as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_board_s),
            "::",
            stringify!(lorawan_public)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_board_s>())).clksrc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_board_s),
            "::",
            stringify!(clksrc)
        )
    );
}
#[doc = "@struct lgw_conf_lbt_chan_s"]
#[doc = "@brief Configuration structure for LBT channels"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_lbt_chan_s {
    pub freq_hz: u32,
    pub scan_time_us: u16,
}
#[test]
fn bindgen_test_layout_lgw_conf_lbt_chan_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_lbt_chan_s>(),
        8usize,
        concat!("Size of: ", stringify!(lgw_conf_lbt_chan_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_lbt_chan_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_lbt_chan_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_chan_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_chan_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lgw_conf_lbt_chan_s>())).scan_time_us as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_chan_s),
            "::",
            stringify!(scan_time_us)
        )
    );
}
#[doc = "@struct lgw_conf_lbt_s"]
#[doc = "@brief Configuration structure for LBT specificities"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_lbt_s {
    pub enable: bool,
    #[doc = "> enable or disable LBT"]
    pub rssi_target: i8,
    #[doc = "> RSSI threshold to detect if channel is busy or not (dBm)"]
    pub nb_channel: u8,
    #[doc = "> number of LBT channels"]
    pub channels: [lgw_conf_lbt_chan_s; 8usize],
    pub rssi_offset: i8,
}
#[test]
fn bindgen_test_layout_lgw_conf_lbt_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_lbt_s>(),
        72usize,
        concat!("Size of: ", stringify!(lgw_conf_lbt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_lbt_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_lbt_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).rssi_target as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(rssi_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).nb_channel as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(nb_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).channels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_lbt_s>())).rssi_offset as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_lbt_s),
            "::",
            stringify!(rssi_offset)
        )
    );
}
#[doc = "@struct lgw_conf_rxrf_s"]
#[doc = "@brief Configuration structure for a RF chain"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lgw_conf_rxrf_s {
    pub enable: bool,
    #[doc = "> enable or disable that RF chain"]
    pub freq_hz: u32,
    #[doc = "> center frequency of the radio in Hz"]
    pub rssi_offset: f32,
    #[doc = "> Board-specific RSSI correction factor"]
    pub type_: lgw_radio_type_e,
    #[doc = "> Radio type for that RF chain (SX1255, SX1257....)"]
    pub tx_enable: bool,
    #[doc = "> enable or disable TX on that RF chain"]
    pub tx_notch_freq: u32,
}
#[test]
fn bindgen_test_layout_lgw_conf_rxrf_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_rxrf_s>(),
        24usize,
        concat!("Size of: ", stringify!(lgw_conf_rxrf_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_rxrf_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_conf_rxrf_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).freq_hz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).rssi_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(rssi_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).tx_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(tx_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxrf_s>())).tx_notch_freq as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxrf_s),
            "::",
            stringify!(tx_notch_freq)
        )
    );
}
impl Default for lgw_conf_rxrf_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_conf_rxif_s"]
#[doc = "@brief Configuration structure for an IF chain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_conf_rxif_s {
    pub enable: bool,
    #[doc = "> enable or disable that IF chain"]
    pub rf_chain: u8,
    #[doc = "> to which RF chain is that IF chain associated"]
    pub freq_hz: i32,
    #[doc = "> center frequ of the IF chain, relative to RF chain frequency"]
    pub bandwidth: u8,
    #[doc = "> RX bandwidth, 0 for default"]
    pub datarate: u32,
    #[doc = "> RX datarate, 0 for default"]
    pub sync_word_size: u8,
    #[doc = "> size of FSK sync word (number of bytes, 0 for default)"]
    pub sync_word: u64,
}
#[test]
fn bindgen_test_layout_lgw_conf_rxif_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_conf_rxif_s>(),
        32usize,
        concat!("Size of: ", stringify!(lgw_conf_rxif_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_conf_rxif_s>(),
        8usize,
        concat!("Alignment of ", stringify!(lgw_conf_rxif_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).rf_chain as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).freq_hz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).bandwidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).datarate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).sync_word_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(sync_word_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_conf_rxif_s>())).sync_word as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_conf_rxif_s),
            "::",
            stringify!(sync_word)
        )
    );
}
#[doc = "@struct lgw_pkt_rx_s"]
#[doc = "@brief Structure containing the metadata of a packet that was received and a pointer to the payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lgw_pkt_rx_s {
    pub freq_hz: u32,
    #[doc = "> central frequency of the IF chain"]
    pub if_chain: u8,
    #[doc = "> by which IF chain was packet received"]
    pub status: u8,
    #[doc = "> status of the received packet"]
    pub count_us: u32,
    #[doc = "> internal concentrator counter for timestamping, 1 microsecond resolution"]
    pub rf_chain: u8,
    #[doc = "> through which RF chain the packet was received"]
    pub modulation: u8,
    #[doc = "> modulation used by the packet"]
    pub bandwidth: u8,
    #[doc = "> modulation bandwidth (LoRa only)"]
    pub datarate: u32,
    #[doc = "> RX datarate of the packet (SF for LoRa)"]
    pub coderate: u8,
    #[doc = "> error-correcting code of the packet (LoRa only)"]
    pub rssi: f32,
    #[doc = "> average packet RSSI in dB"]
    pub snr: f32,
    #[doc = "> average packet SNR, in dB (LoRa only)"]
    pub snr_min: f32,
    #[doc = "> minimum packet SNR, in dB (LoRa only)"]
    pub snr_max: f32,
    #[doc = "> maximum packet SNR, in dB (LoRa only)"]
    pub crc: u16,
    #[doc = "> CRC that was received in the payload"]
    pub size: u16,
    #[doc = "> payload size in bytes"]
    pub payload: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_lgw_pkt_rx_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_pkt_rx_s>(),
        300usize,
        concat!("Size of: ", stringify!(lgw_pkt_rx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_pkt_rx_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_pkt_rx_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).if_chain as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(if_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).status as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).count_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(count_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).rf_chain as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).modulation as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).bandwidth as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).datarate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).coderate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(coderate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).rssi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr_min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).snr_max as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(snr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).crc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).size as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_rx_s>())).payload as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_rx_s),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for lgw_pkt_rx_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_pkt_tx_s"]
#[doc = "@brief Structure containing the configuration of a packet to send and a pointer to the payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lgw_pkt_tx_s {
    pub freq_hz: u32,
    #[doc = "> center frequency of TX"]
    pub tx_mode: u8,
    #[doc = "> select on what event/time the TX is triggered"]
    pub count_us: u32,
    #[doc = "> timestamp or delay in microseconds for TX trigger"]
    pub rf_chain: u8,
    #[doc = "> through which RF chain will the packet be sent"]
    pub rf_power: i8,
    #[doc = "> TX power, in dBm"]
    pub modulation: u8,
    #[doc = "> modulation to use for the packet"]
    pub bandwidth: u8,
    #[doc = "> modulation bandwidth (LoRa only)"]
    pub datarate: u32,
    #[doc = "> TX datarate (baudrate for FSK, SF for LoRa)"]
    pub coderate: u8,
    #[doc = "> error-correcting code of the packet (LoRa only)"]
    pub invert_pol: bool,
    #[doc = "> invert signal polarity, for orthogonal downlinks (LoRa only)"]
    pub f_dev: u8,
    #[doc = "> frequency deviation, in kHz (FSK only)"]
    pub preamble: u16,
    #[doc = "> set the preamble length, 0 for default"]
    pub no_crc: bool,
    #[doc = "> if true, do not send a CRC in the packet"]
    pub no_header: bool,
    #[doc = "> if true, enable implicit header mode (LoRa), fixed length (FSK)"]
    pub size: u16,
    #[doc = "> payload size in bytes"]
    pub payload: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_lgw_pkt_tx_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_pkt_tx_s>(),
        288usize,
        concat!("Size of: ", stringify!(lgw_pkt_tx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_pkt_tx_s>(),
        4usize,
        concat!("Alignment of ", stringify!(lgw_pkt_tx_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).freq_hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).tx_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(tx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).count_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(count_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).rf_chain as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(rf_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).rf_power as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(rf_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).modulation as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).bandwidth as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).datarate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(datarate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).coderate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(coderate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).invert_pol as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(invert_pol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).f_dev as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(f_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).preamble as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(preamble)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).no_crc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(no_crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).no_header as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(no_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_pkt_tx_s>())).payload as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_pkt_tx_s),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for lgw_pkt_tx_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "@struct lgw_tx_gain_s"]
#[doc = "@brief Structure containing all gains of Tx chain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_tx_gain_s {
    pub dig_gain: u8,
    #[doc = "> 2 bits, control of the digital gain of SX1301"]
    pub pa_gain: u8,
    #[doc = "> 2 bits, control of the external PA (SX1301 I/O)"]
    pub dac_gain: u8,
    #[doc = "> 2 bits, control of the radio DAC"]
    pub mix_gain: u8,
    #[doc = "> 4 bits, control of the radio mixer"]
    pub rf_power: i8,
}
#[test]
fn bindgen_test_layout_lgw_tx_gain_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_tx_gain_s>(),
        5usize,
        concat!("Size of: ", stringify!(lgw_tx_gain_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_tx_gain_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_tx_gain_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).dig_gain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(dig_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).pa_gain as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(pa_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).dac_gain as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(dac_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).mix_gain as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(mix_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_s>())).rf_power as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_s),
            "::",
            stringify!(rf_power)
        )
    );
}
#[doc = "@struct lgw_tx_gain_lut_s"]
#[doc = "@brief Structure defining the Tx gain LUT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lgw_tx_gain_lut_s {
    pub lut: [lgw_tx_gain_s; 16usize],
    #[doc = "> Array of Tx gain struct"]
    pub size: u8,
}
#[test]
fn bindgen_test_layout_lgw_tx_gain_lut_s() {
    assert_eq!(
        ::std::mem::size_of::<lgw_tx_gain_lut_s>(),
        81usize,
        concat!("Size of: ", stringify!(lgw_tx_gain_lut_s))
    );
    assert_eq!(
        ::std::mem::align_of::<lgw_tx_gain_lut_s>(),
        1usize,
        concat!("Alignment of ", stringify!(lgw_tx_gain_lut_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_lut_s>())).lut as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_lut_s),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lgw_tx_gain_lut_s>())).size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lgw_tx_gain_lut_s),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = "@brief Configure the gateway board"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_board_setconf(conf: lgw_conf_board_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure the gateway lbt function"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_lbt_setconf(conf: lgw_conf_lbt_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure an RF chain (must configure before start)"]
    #[doc = "@param rf_chain number of the RF chain to configure [0, LGW_RF_CHAIN_NB - 1]"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_rxrf_setconf(rf_chain: u8, conf: lgw_conf_rxrf_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure an IF chain + modem (must configure before start)"]
    #[doc = "@param if_chain number of the IF chain + modem to configure [0, LGW_IF_CHAIN_NB - 1]"]
    #[doc = "@param conf structure containing the configuration parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_rxif_setconf(if_chain: u8, conf: lgw_conf_rxif_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Configure the Tx gain LUT"]
    #[doc = "@param pointer to structure defining the LUT"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_txgain_setconf(conf: *mut lgw_tx_gain_lut_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Connect to the LoRa concentrator, reset it and configure it according to previously set parameters"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Stop the LoRa concentrator and disconnect it"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief A non-blocking function that will fetch up to 'max_pkt' packets from the LoRa concentrator FIFO and data buffer"]
    #[doc = "@param max_pkt maximum number of packet that must be retrieved (equal to the size of the array of struct)"]
    #[doc = "@param pkt_data pointer to an array of struct that will receive the packet metadata and payload pointers"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, else the number of packets retrieved"]
    pub fn lgw_receive(max_pkt: u8, pkt_data: *mut lgw_pkt_rx_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Schedule a packet to be send immediately or after a delay depending on tx_mode"]
    #[doc = "@param pkt_data structure containing the data and metadata for the packet to send"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    #[doc = ""]
    #[doc = "circuitry to start and be stable. This delay is adjusted by the HAL depending"]
    #[doc = "on the board version (lgw_i_tx_start_delay_us)."]
    #[doc = ""]
    #[doc = "In 'timestamp' mode, this is transparent: the modem is started"]
    #[doc = "lgw_i_tx_start_delay_us microseconds before the user-set timestamp value is"]
    #[doc = "reached, the preamble of the packet start right when the internal timestamp"]
    #[doc = "counter reach target value."]
    #[doc = ""]
    #[doc = "In 'immediate' mode, the packet is emitted as soon as possible: transferring the"]
    #[doc = "packet (and its parameters) from the host to the concentrator takes some time,"]
    #[doc = "then there is the lgw_i_tx_start_delay_us, then the packet is emitted."]
    #[doc = ""]
    #[doc = "In 'triggered' mode (aka PPS/GPS mode), the packet, typically a beacon, is"]
    #[doc = "emitted lgw_i_tx_start_delay_us microsenconds after a rising edge of the"]
    #[doc = "trigger signal. Because there is no way to anticipate the triggering event and"]
    #[doc = "start the analog circuitry beforehand, that delay must be taken into account in"]
    #[doc = "the protocol."]
    pub fn lgw_send(pkt_data: lgw_pkt_tx_s) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Give the the status of different part of the LoRa concentrator"]
    #[doc = "@param select is used to select what status we want to know"]
    #[doc = "@param code is used to return the status code"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_status(select: u8, code: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Abort a currently scheduled or ongoing TX"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_abort_tx() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Return value of internal counter when latest event (eg GPS pulse) was captured"]
    #[doc = "@param trig_cnt_us pointer to receive timestamp value"]
    #[doc = "@return LGW_HAL_ERROR id the operation failed, LGW_HAL_SUCCESS else"]
    pub fn lgw_get_trigcnt(trig_cnt_us: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@brief Allow user to check the version/options of the library once compiled"]
    #[doc = "@return pointer on a human-readable null terminated string"]
    pub fn lgw_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Return time on air of given packet, in milliseconds"]
    #[doc = "@param packet is a pointer to the packet structure"]
    #[doc = "@return the packet time on air in milliseconds"]
    pub fn lgw_time_on_air(packet: *mut lgw_pkt_tx_s) -> u32;
}
extern "C" {
    #[doc = "@brief Connect LoRa concentrator by opening SPI link"]
    #[doc = "@param spi_only indicates if we only want to create the SPI connexion to the"]
    #[doc = "concentrator, or if we also want to reset it and configure the FPGA (if present)"]
    #[doc = "@param tx_notch_filter TX notch filter frequency to be set in the FPGA (only"]
    #[doc = "used with SX1301AP2 reference design)."]
    #[doc = "@return status of register operation (LGW_REG_SUCCESS/LGW_REG_ERROR)"]
    pub fn lgw_connect(spi_only: bool, tx_notch_freq: u32) -> ::std::os::raw::c_int;
}
